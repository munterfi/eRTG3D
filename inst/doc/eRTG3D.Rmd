---
title: "Empirically Informed Random Trajectory Generator in 3-D"
author: "Unterfinger Merlin"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Empirically Informed Random Trajectory Generator in 3-D}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
abstract: "The empirically informed Random Trajectory Generator in three dimensions **eRTG3D** is an algorithm to generate realistic random trajectories in a 3-D space between two given fix points in space. The trajectory generation is based on empirical distribution functions extracted from observed trajectories and thus reflects the geometrical movement characteristics of the mover."
editor_options: 
  chunk_output_type: console
---

<style>
body {
text-align: justify}
</style>

```{r, echo = FALSE, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
options(knitr.table.format = "html")

library(eRTG3D)
set.seed(123)
cerwList <- reproduce.track.3d(n.sim = 100, multicore=TRUE, niclas, DEM = dem, BG = (dem<650), filterDeadEnds = TRUE, maxBin = 50, gradientDensity = TRUE)
cerw <- cerwList[[1]]
```

## Introduction
This vignette illustrates the basic functionality of the `eRTG3D` package and some workflows, to combine the functions in a meaningful way. For a more detailed description of the individual functions and their parameters please consider the package's help.

## Test functionality of the eRTG3D
To check if the eRTG3D package is installed properly, run the following lines:
```{r, eval = FALSE, fig.show='hold'}
library(eRTG3D)
test.eRTG.3d()
```

To test the parallel version use `test.eRTG.3d(multicore = TRUE)`. To test also the plot functions and check the results:
```{r, eval = FALSE, fig.show='hold'}
results <- test.eRTG.3d(returnResult = TRUE, plot2d = TRUE, plot3d = TRUE)
```

## Coordinate reference system transformations
The eRTG3D only supports calculations in *Cartesian* coordinate systems. In case of latitude / longitude data (e.g.: WGS84), these must be converted into a *Cartesian* coordinate system, as for example the Universal Transverse Mercator (UTM).

To carry out a CRS transformation, please use `transformCRS.3d()`, which is based on the `st_transform()` from the `sf` package. Therefore is supports CRS transformations in 3D.

```{r eval=FALSE}
WGS84 <- "+init=epsg:4326"
LV95 <- "+init=epsg:2056"
track <- transformCRS.3d(track, fromCRS=WGS84, toCRS=LV95)
```

**Note:** `spTransform()` from the `sp` package only supports transformations in the 2-D plane, which will cause distortions in the third dimension.

## Test data
An example GPS track of a stork `niclas` and an example Digital Elevation Model `dem` are included in the package. The DEM is a snippet from the *SRTM 90m Digital Elevation Database v4.1* from [cgiar-csi.org](www.cgiar-csi.org) and the stork track is a subset of the data in the study *LifeTrack White Stork SWGermany 2014-2017* (Movebank Study ID 21231406) from the [Movebank Data Repository](www.datarepository.movebank.org). 

The area covered by the test data is the Swiss midland. The example track is a data.frame with coordinates in x, y and z. The x and y coordinates are in the CH1903+ / LV95 (EPSG:2056) reference system. The DEM is a rasterLayer of the raster package, it's Coordinate Reference System (CRS) is also CH1903+ / LV95. The stork flies from southwest to northeast, GPS fixes are collected every 15 minutes.

## Standart workflow of the eRTG3D
As first step the properties of a track with x, y and z coordinates are calculated.

```{r eval=FALSE}
niclas <- track.properties.3d(niclas)
```

```{r echo=FALSE, results = "asis", fig.height=5, fig.width=10}
niclas <- track.properties.3d(niclas)
pander::pandoc.table(head(round(niclas, 2),5))
```

Then the densities from the track are extracted. Although the algorithm also works without DEM, the DEM should be passed to the `get.track.densities.3d()` function, otherwise the flight height distribution in respect to the earth surface can not be built, which ends in less accurate results.

```{r eval=FALSE}
D <- get.track.densities.3d(niclas, heightDistEllipsoid = TRUE, DEM = dem)
```

The finally desired Conditional Empirical Random Walk (CERW) connecting a given start with a certain end point by a given number of steps needs an attraction term (the Q probability) to ensure that the target is approached and hit.
In order to calculate the Q probability for each step the distribution of turns and lifts to target and the distribution of distance to target has to be known. They can be derived from the empirical data (ideally),
or estimated from an unconditional process with the same properties. In this case the Q probabilities, which represent the pull towards the destination, are extracted from a UERW simulated with `sim.uncond.3d()`. The UERW should contain 1500 `f <- 1500` times more steps than the final CERW to be simulated. Q are extracted from the UERW by the function `qProb.3d()`.

```{r eval=FALSE}
sim.locs <- nrow(niclas)
f <- 1500
uerw <- sim.uncond.3d(sim.locs*f, start = c(niclas$x[1], niclas$y[1], niclas$z[1]), 
                      a0 = niclas$a[1], g0 = niclas$g[1], densities = D)
Q <- qProb.3d(uerw, sim.locs)
```

Set up the start conditions: azimuth (`a0`), gradient (`g0`), start and end point of the CERW to be simulated.

```{r eval=FALSE}
start=c(niclas$x[1],niclas$y[1],niclas$z[1])
end=c(niclas$x[nrow(niclas)],niclas$y[nrow(niclas)],niclas$z[nrow(niclas)])
a0 = niclas$a[1]
g0 = niclas$g[1]
```

Then finally a CERW can be simulated.

```{r eval=FALSE}
cerw <- sim.cond.3d(sim.locs, start=start, end=end, a0 = a0, g0 = g0, densities=D, qProbs=Q, DEM = dem)
```

If more than one simulated track is desired, the `n.sim.cond.3d()` can be used. The n.sim parameter defines the number of simulated tracks.

```{r eval=FALSE}
cerwList <- n.sim.cond.3d(n.sim = 100, sim.locs, start=start, end=end, a0 = a0, g0 = g0, densities=D, qProbs=Q, DEM = dem)
```

**Note:** Due to dead ends, which are normally occurring in a proportion of 25%, the n.sim parameter should be set higher than the needed tracks.

## Extract densities from multiple track sections
In many cases the time between the acquisition of fix points of the GPS tracks is not constant.
This can be caused by the time to get the fix point or missing data. To avoid distorted statistic distributions,
which increases the probability of dead ends, the track has to be splitted in sections, where the acquisition time is constant. In this case the `get.track.properties.3d()` function can not be used anymore. Then the work flow should look like the following:

```{r eval=FALSE}
trackSections <- track.split.3d(track, timeLag)
D <- get.section.densities.3d(trackSections, DEM = dem)
```

**Note:** If the aim is to reproduce a track, then the length of the track should be adjusted to fit to the densities extracted by `get.section.densities.3d()`. The message thrown by the previously applied `track.split.3d()` proposes a value `nChange` to change the track length of the simulations.

## Wrapped function to reproduce tracks
To reproduce an observed track, it is the simplest to just apply the `reproduce.track.3d()` function on the track and the DEM. The function automatically wraps all steps above together. To produce multiple tracks, the `n.sim` variable can be used.

```{r, fig.show='hold', eval=FALSE}
cerwList <- reproduce.track.3d(n.sim = 100, niclas, DEM = dem)
```

## Verify results
The obtained result should be tested statistically. The first argument of the `test.verification.3d()` function is the original track to be tested against. The second argument is either a single track...

```{r eval=TRUE}
tests <- test.verification.3d(niclas, cerw, plot = FALSE)
```

... or a list of multiple tracks.

```{r eval=TRUE}
tests <- test.verification.3d(niclas, cerwList, plot = FALSE)
```

## Visualize results
The resulting tracks can be plotted either in 2D or in 3D, using the `ggplot2` and `plotly` libraries. Additionally the densities of the track properties can be visualized.

### Densities of turn angle, lift angle and step length of tracks
The function takes either one or two tracks. The second track can be a list of tracks as for example the output of `n.sim.cons.3d()`. In this case the densities of turn angle, lift angle and step length of all the simulations is taken. Additionally the `autodifferences` parameter can be set to `TRUE`, then the densities of the auto differences in turn angle, lift angle and step length are visualized.

```{r eval=TRUE, fig.height=5, fig.width=7}
plot3d.densities(niclas, cerwList)
```

### 2-D Plot
The `plot2d()` function takes either one or two arguments. The second argument can be a single track data.frame or list of track data.frames as for example the output of `n.sim.cons.3d()`. Also a DEM rasterLayer can be passed to the function.

```{r eval=TRUE, fig.height=5, fig.width=7}
plot2d(niclas, cerwList, titleText=paste("Steps: ", nrow(niclas), ", Niclas", sep=""), DEM=dem)
```

### 3-D Plot

The `plot3d()` function takes either one or two arguments. The second argument can be a single track data.frame or list of track data.frames as for example the output of `n.sim.cons.3d()`. Also a DEM rasterLayer, which is plotted as a surface can be passed to the function.

```{r eval=FALSE}
plot3d(niclas, cerwList, titleText=paste("Steps: ", nrow(niclas), ", Niclas", sep=""), DEM=dem)
```
<img src="figs/plot3d.png" alt="Drawing" style="width: 96.5%;"/>

## Parallel computing
The computationally most intense functions `qProb.3d()`, `n.sim.uncond.3d()` and `reproduce.track.3d()` of the package are also implemented in a parallel version. On Unix systems this is done with the `parallel` package. On Windows systems, a combination of the packages `doParallel`, `parallel` and `plyr` ones is used. These versions can be accessed by setting the parameter `multicore=TRUE`.

```{r eval=FALSE, fig.height=5, fig.width=7}
Q <- qProb.3d(uerw, sim.locs, multicore=TRUE)
cerwList <- reproduce.track.3d(n.sim = 100, niclas, DEM = dem, multicore=TRUE)
```

```{r eval=TRUE, echo=FALSE, fig.height=5, fig.width=7, include=FALSE}
D <- get.track.densities.3d(niclas, heightDistEllipsoid = TRUE, DEM = dem)
sim.locs <- nrow(niclas)
f <- 1500
uerw <- sim.uncond.3d(sim.locs*f, start = c(niclas$x[1], niclas$y[1], niclas$z[1]), 
                      a0 = niclas$a[1], g0 = niclas$g[1], densities = D)
Q <- qProb.3d(uerw, sim.locs)
start=c(niclas$x[1],niclas$y[1],niclas$z[1])
end=c(niclas$x[sim.locs],niclas$y[sim.locs],niclas$z[sim.locs])
a0 = niclas$a[1]
g0 = niclas$g[1]
```

And a running example:

```{r eval=TRUE, fig.height=5, fig.width=7}
cerw <- n.sim.cond.3d(n.sim = 100, sim.locs, start=start, end=end, a0 = a0, g0 = g0, densities=D, qProbs=Q, DEM = dem, multicore=TRUE)
```

**Note:** If only a few tracks are simulated and the track length is short `sim.locs < 30`, then it is faster in many cases to stay with the single core version of the function, especially on Windows systems, where setting up clusters takes some time.

## Linkage to the 'sf' package
The `sf` package delivers a standardized way to encode spatial vector data, the so called Simple Features (SF). It binds to GDAL for reading and writing data, to GEOS for geometrical operations, and to Proj.4 for projection conversions and datum transformations. Therefore the `eRTG3D` package comes with some wrapper functions to convert the generated tracks to simple features. The resulting `sf, data.frame` objects enable access to the functionality of the sf package, which also includes an easy ways to access spatial databases (PostGIS).

To convert tracks to a an object of type `sf, data.frame` use the `track2sf.3d()` function, which can take data.frames, matrices and move objects (containing one track!) as input. In case of data.frames and matrices, it is important that the coordinates are stored in the first three rows.

```{r eval=TRUE, fig.height=5, fig.width=7}
LV95 <- "+init=epsg:2056"
niclas <- track2sf.3d(niclas, CRS = LV95)
is.sf.3d(niclas)
head(niclas, 3)
```

To test if a track is of type `sf, data.frame` use the `is.sf()` function. and to convert a `sf, data.frame` back to a track data.frame use `sf2df.3d()`.

```{r eval=TRUE, fig.height=5, fig.width=7}
niclas <- sf2df.3d(niclas)
is.sf.3d(niclas)
```

## License
This R package is licensed under the GPL (>= 3) License.
