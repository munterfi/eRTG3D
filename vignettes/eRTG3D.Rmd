---
title: "Empirically Informed Random Trajectory Generator in 3-D"
author: "Unterfinger Merlin"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Empirically Informed Random Trajectory Generator in 3-D}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
abstract: "The empirically informed random trajectory generator in three dimensions (eRTG3D)
             is an algorithm to generate realistic random trajectories in a 3-D space
             between two given fix points in space. The trajectory generation is based on
             empirical distribution functions extracted from observed trajectories (training data)
             and thus reflects the geometrical movement characteristics of the mover."
---

<style>
body {
text-align: justify}
</style>

```{r, echo = FALSE, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
options(knitr.table.format = "html")

library(eRTG3D)
set.seed(123)
cerwList <- reproduce.track.3d(n.sim = 100, multicore=TRUE, niclas, DEM = dem, BG = (dem<650), filterDeadEnds = TRUE)
cerw <- filter.dead.ends(cerwList)[[1]]
```

## Introduction
This vignette illustrates the basic functionality of the **eRTG3D** package and some workflows, to combine the functions in a meaningful way. For a more detailed description of the individual functions and their parameters please consider the package's help.

## Test functionality of the eRTG3D
To check if the eRTG3D packages is installed properly, run the following lines:
```{r, eval = FALSE, fig.show='hold'}
library(eRTG3D)
test.eRTG.3d()
```

To test the parallel version:
```{r, eval = FALSE, fig.show='hold'}
test.eRTG.3d(multicore = TRUE)
```

And to test also the plot functions and check the results:
```{r, eval = FALSE, fig.show='hold'}
results <- test.eRTG.3d(returnResult = TRUE, plot2d = TRUE, plot3d = TRUE)
```

## Testdata
An example GPS track of a stork (`niclas`) and an example Digital Elevation Model (`dem`) are included in the package. The DEM is a snippet from the **SRTM 90m Digital Elevation Database v4.1** from [cgiar-csi.org](www.cgiar-csi.org) and the stork track is a subset of the data in the study "LifeTrack White Stork SWGermany 2014-2017" (Movebank Study ID 21231406) from the [Movebank Data Repository](www.datarepository.movebank.org). 

The area covered by the test data is the Swiss midland. The example track is a data.frame with coordinates in x, y and z. The x and y coordinates are in the CH1903+ / LV95 (EPSG:2056) reference system. The DEM is a rasterLayer of the raster package, it's coordinate reference system (CRS) is also CH1903+ / LV95. The stork flies from southwest to northeast, GPS fixes are collected every 15 minutes.

## Standart workflow of the eRTG3D
As first step the properties of a track with x, y and z coordinates are calculated.

```{r eval=FALSE}
niclas <- track.properties.3d(niclas)
```

```{r echo=FALSE, results = "asis", fig.height=5, fig.width=10}
niclas <- track.properties.3d(niclas)
niclas[c("dx", "dy", "dz", "d2d")] <- NULL
pander::pandoc.table(head(round(niclas, 2),5))
```

Then the densities from the tracks are extracted. Although the algorithm also works without DEM, the DEM should be passed to the `get.densities.3d()` function, otherwise the flight height distribution in respect to the earth surface can not be built, which ends in less accurate results.

```{r eval=FALSE}
D <- get.densities.3d(niclas, heightDistEllipsoid = TRUE, DEM = dem)
```

Then an Unconditional Empirical Random Walk (UERW) is simulated, which contains 1500 times more steps than the track to be simulated. From the resulting UERW the Q probabilities, which represent the pull towards the destination, are extracted.

```{r eval=FALSE}
sim.locs <- nrow(niclas)
f <- 1500
uerw <- sim.uncond.3d(sim.locs*f, start = c(niclas$x[1], niclas$y[1], niclas$z[1]), 
                      a0 = niclas$a[1], g0 = niclas$g[1], densities = D)
Q <- qProb.3d(uerw, sim.locs)
```

Set up the start conditions: azimuth (`a0`), gradient (`g0`), start and end point of the track to be simulated.
```{r eval=FALSE}
start=c(niclas$x[1],niclas$y[1],niclas$z[1])
end=c(niclas$x[sim.locs],niclas$y[sim.locs],niclas$z[sim.locs])
a0 = niclas$a[1]
g0 = niclas$g[1]
```

Then finally a Conditional Empirical Random Walk (CERW) can be simulated.
```{r eval=FALSE}
cerw <- sim.cond.3d(sim.locs, start=start, end=end, a0 = a0, g0 = g0, densities=D, qProbs=Q, DEM = dem)
```

If more than one simulated track is desired, the `n.sim.cond.3d()` can be used. The n.sim parameter defines the number of simulated tracks. NOTE: Due to dead ends, which are normally occurring in a proportion of 25%, the n.sim parameter should be set higher than the needed tracks.

```{r eval=FALSE}
cerw <- n.sim.cond.3d(n.sim = 100, sim.locs, start=start, end=end, a0 = a0, g0 = g0, densities=D, qProbs=Q, DEM = dem)
```

## Wrapped function to reproduce tracks
To reproduce an observed track, it is the simplest to just apply the `reproduce.track.3d()` function on the track and the DEM. The function automatically wraps all steps above together. To produce multiple tracks, the n.sim variable can be used (eg. `n.sim = 100`).

```{r, fig.show='hold', eval=FALSE}
cerwList <- reproduce.track.3d(n.sim = 100, niclas, DEM = dem)
```

## Verify results
The obtained result should be tested statistically. The first argument of the `test.verification.3d()` function is the original track to be tested against. The second argument is either a single track

```{r eval=TRUE, fig.height=5, fig.width=7}
tests <- test.verification.3d(niclas, cerw, plotDensities = FALSE)
```

... or a list of multiple tracks.

```{r eval=TRUE, fig.height=5, fig.width=7}
tests <- test.verification.3d(niclas, cerwList, plotDensities = FALSE)
```

## Visualize results
The resulting tracks can be plotted either in 2D or in 3D, using the 'ggplot2' and 'plotly' libraries. Additionally the densities of the track properties can be visualized.

### Densities of turn angle, lift angle and step length of tracks
The function takes either one or two tracks. The second track can be a list of tracks (eg. the output of `n.sim.cons.3d()`), Then the densities of turn angle, lift angle and step length of all the simulations is taken. Additionally the autodifferences parameter can be set to true, then the densities of the autodifferences in turn angle, lift angle and step length are visualized.

```{r eval=TRUE, fig.height=5, fig.width=7}
plot2d.densities(niclas, cerwList)
```

### 2-D Plots
The `plot2d()` function takes either one or two arguments. The second argument can be a single track data.frame or list of track data.frames (eg. the output of `n.sim.cons.3d()`). Also a DEM rasterLayer can be passed to the function.

```{r eval=TRUE, fig.height=5, fig.width=7}
plot2d(niclas, cerwList, titleText=paste("Steps: ", nrow(niclas), ", Niclas", sep=""), DEM=dem)
```

### 3-D Plot

The `plot3d()` function takes either one or two arguments. The second argument can be a single track data.frame or list of track data.frames (eg. the output of `n.sim.cons.3d()`). Also a DEM rasterLayer, which is plotted as a surface can be passed to the function.

```{r eval=FALSE, fig.height=5, fig.width=7}
plot3d(niclas, cerw, titleText=paste("Steps: ", nrow(niclas), ", Niclas", sep=""), surface=TRUE, DEM=dem)
```

## Parallel computing

The computationally most intense functions (`qProb.3d()`, `n.sim.uncond.3d()` and `reproduce.track.3d()`) of the package are also implemented in a parallel version. On Unix systems this is done with the `parallel` package. On Windows systems, a combination of the packages `doParallel`, `parallel` and `plyr` ones is used. These versions can be acessed by setting the paramater `multicore=TRUE`. If only a few tracks are simulated and the track length is short (< 30), then it is faster in many cases to stay with the singlecore version of the function, especially on Windows systems, where setting up clusters takes some time.

```{r eval=FALSE, fig.height=5, fig.width=7}
Q <- qProb.3d(uerw, sim.locs, multicore=TRUE)
cerwList <- reproduce.track.3d(n.sim = 100, niclas, DEM = dem, multicore=TRUE)
```

```{r eval=TRUE, echo=FALSE, fig.height=5, fig.width=7, include=FALSE}
D <- get.densities.3d(niclas, heightDistEllipsoid = TRUE, DEM = dem)
sim.locs <- nrow(niclas)
f <- 1500
uerw <- sim.uncond.3d(sim.locs*f, start = c(niclas$x[1], niclas$y[1], niclas$z[1]), 
                      a0 = niclas$a[1], g0 = niclas$g[1], densities = D)
Q <- qProb.3d(uerw, sim.locs)
start=c(niclas$x[1],niclas$y[1],niclas$z[1])
end=c(niclas$x[sim.locs],niclas$y[sim.locs],niclas$z[sim.locs])
a0 = niclas$a[1]
g0 = niclas$g[1]
```

And a running example:

```{r eval=TRUE, fig.height=5, fig.width=7}
cerw <- n.sim.cond.3d(n.sim = 100, sim.locs, start=start, end=end, a0 = a0, g0 = g0, densities=D, qProbs=Q, DEM = dem, multicore=TRUE)
```

## License

This R package is licensed under the GPL (>= 3) License.
